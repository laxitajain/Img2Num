"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[5975],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var t=i(96540);const o={},l=t.createContext(o);function s(e){const n=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(l.Provider,{value:n},e.children)}},64662:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"reference/wasm/modules/image/mergeSmallRegionsInPlace/limitations-and-pitfalls","title":"Limitations & Pitfalls","description":"Limitations and pitfalls commonly encountered when using the mergeSmallRegionsInPlace function.","source":"@site/docs/reference/wasm/modules/image/mergeSmallRegionsInPlace/limitations-and-pitfalls.md","sourceDirName":"reference/wasm/modules/image/mergeSmallRegionsInPlace","slug":"/reference/wasm/modules/image/mergeSmallRegionsInPlace/limitations-and-pitfalls","permalink":"/Img2Num/info/docs/reference/wasm/modules/image/mergeSmallRegionsInPlace/limitations-and-pitfalls","draft":false,"unlisted":false,"editUrl":"https://github.com/Ryan-Millard/Img2Num/edit/main/docs/docs/reference/wasm/modules/image/mergeSmallRegionsInPlace/limitations-and-pitfalls.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"id":"limitations-and-pitfalls","title":"Limitations & Pitfalls","sidebar_label":"Limitations & Pitfalls","sidebar_position":7,"description":"Limitations and pitfalls commonly encountered when using the mergeSmallRegionsInPlace function."},"sidebar":"tutorialSidebar","previous":{"title":"Complexity and Memory","permalink":"/Img2Num/info/docs/reference/wasm/modules/image/mergeSmallRegionsInPlace/complexity-and-memory"},"next":{"title":"Variants & Improvements","permalink":"/Img2Num/info/docs/reference/wasm/modules/image/mergeSmallRegionsInPlace/variants-and-improvements"}}');var o=i(74848),l=i(28453);const s={id:"limitations-and-pitfalls",title:"Limitations & Pitfalls",sidebar_label:"Limitations & Pitfalls",sidebar_position:7,description:"Limitations and pitfalls commonly encountered when using the mergeSmallRegionsInPlace function."},a=void 0,r={},c=[{value:"Exact RGBA equality",id:"exact-rgba-equality",level:2},{value:"Only 4-connectivity",id:"only-4-connectivity",level:2},{value:"Local merge heuristic",id:"local-merge-heuristic",level:2},{value:"Holes / concavities",id:"holes--concavities",level:2},{value:"Order sensitivity",id:"order-sensitivity",level:2},{value:"Performance",id:"performance",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"exact-rgba-equality",children:"Exact RGBA equality"}),"\n",(0,o.jsxs)(n.p,{children:["The algorithm treats colors as equal only when all 4 bytes match exactly.\nIf you need fuzzy color merging (e.g. colors within a Euclidean distance in RGB), you must replace ",(0,o.jsx)(n.code,{children:"sameColor"})," with a colour-distance test."]}),"\n",(0,o.jsx)(n.admonition,{title:"Extending functionality",type:"note",children:(0,o.jsx)(n.p,{children:"This could be extended in the future by allowing callers to pass a custom equality-checker function."})}),"\n",(0,o.jsx)(n.h2,{id:"only-4-connectivity",children:"Only 4-connectivity"}),"\n",(0,o.jsx)(n.p,{children:"Components connected only diagonally will be considered separate. If your semantics require 8-connectivity, adapt the neighbour set."}),"\n",(0,o.jsx)(n.h2,{id:"local-merge-heuristic",children:"Local merge heuristic"}),"\n",(0,o.jsxs)(n.p,{children:["A small region is colored using the first adjacent large neighbour encountered.\nIf a small island touches multiple large regions, the chosen one depends on neighbour scan order\n(right, left, down, up in the reference code). This can occasionally lead to confusion as it is not an ",(0,o.jsx)(n.code,{children:"intelligent check"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"holes--concavities",children:"Holes / concavities"}),"\n",(0,o.jsxs)(n.p,{children:["The bounding-box test may be fooled by shapes with large bounding boxes but containing many holes.\n",(0,o.jsx)(n.strong,{children:"The TODO in the source code remains valid"}),": you could compute convex-hull, morphological closing,\nor compute the ratio ",(0,o.jsx)(n.code,{children:"size / (width*height)"})," (occupancy) to detect sparse shapes."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",metastring:'title="The TODO comment"',children:"// TODO: check for gaps inside regions - its possible their dimensions are fine,\n// but inner gaps reduce effective width and height\n"})}),"\n",(0,o.jsx)(n.h2,{id:"order-sensitivity",children:"Order sensitivity"}),"\n",(0,o.jsxs)(n.p,{children:["Since pixels are recolored in place and have their ",(0,o.jsx)(n.code,{children:"labels"})," updated  when a merge is done,\nsubsequent small pixels that were adjacent to that pixel may now see a different neighbour label;\nthis actually helps the merge flood (small pixels adjacent to a merged pixel can be recoloured to the same large region),\nbut it means the behaviour is implementation-order dependent."]}),"\n",(0,o.jsx)(n.h2,{id:"performance",children:"Performance"}),"\n",(0,o.jsxs)(n.p,{children:["Allocation of ",(0,o.jsx)(n.code,{children:"std::vector<int>"})," and ",(0,o.jsx)(n.code,{children:"std::queue"})," can be optimized for very large images."]})]})}function m(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);