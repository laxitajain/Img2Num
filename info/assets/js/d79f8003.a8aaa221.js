"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2786],{28453:(e,t,i)=>{i.d(t,{R:()=>d,x:()=>o});var s=i(96540);const r={},n=s.createContext(r);function d(e){const t=s.useContext(n);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),s.createElement(n.Provider,{value:t},e.children)}},73826:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"reference/wasm/modules/image/fft_iterative/api","title":"Iterative FFT \u2014 API & Reference","description":"Quick reference for the functions implemented in the header. Use this as a clipboard-friendly cheat sheet.","source":"@site/docs/reference/wasm/modules/image/fft_iterative/api.md","sourceDirName":"reference/wasm/modules/image/fft_iterative","slug":"/reference/wasm/modules/image/fft_iterative/api","permalink":"/Img2Num/info/docs/reference/wasm/modules/image/fft_iterative/api","draft":false,"unlisted":false,"editUrl":"https://github.com/Ryan-Millard/Img2Num/edit/main/docs/docs/reference/wasm/modules/image/fft_iterative/api.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"api","title":"Iterative FFT \u2014 API & Reference","sidebar_label":"API / Usage","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Implementation","permalink":"/Img2Num/info/docs/reference/wasm/modules/image/fft_iterative/implementation"},"next":{"title":"Implementation Explained","permalink":"/Img2Num/info/docs/reference/wasm/modules/image/fft_iterative/explained"}}');var r=i(74848),n=i(28453);const d={id:"api",title:"Iterative FFT \u2014 API & Reference",sidebar_label:"API / Usage",sidebar_position:5},o="Iterative FFT \u2014 API & Reference",c={},a=[];function l(e){const t={admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",header:"header",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"iterative-fft--api--reference",children:"Iterative FFT \u2014 API & Reference"})}),"\n",(0,r.jsx)(t.p,{children:"Quick reference for the functions implemented in the header. Use this as a clipboard-friendly cheat sheet."}),"\n",(0,r.jsxs)(t.admonition,{title:"Power-of-two padding & resizing",type:"danger",children:[(0,r.jsxs)(t.p,{children:["This FFT implementation ",(0,r.jsx)(t.strong,{children:"requires power-of-two sizes"}),"."]}),(0,r.jsxs)(t.p,{children:["If the input length (1D) or dimensions (2D) are ",(0,r.jsx)(t.strong,{children:"not"})," powers of two, the input buffer is ",(0,r.jsx)(t.strong,{children:"automatically zero-padded and resized"})," to the next power of two ",(0,r.jsx)(t.strong,{children:"before"})," the transform is performed."]}),(0,r.jsx)(t.p,{children:"As a result:"}),(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The FFT ",(0,r.jsx)(t.strong,{children:"does NOT always return the same size as the input"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"iterative_fft"})," and ",(0,r.jsx)(t.code,{children:"fft_copy"})," may ",(0,r.jsx)(t.strong,{children:"resize the input vector"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"iterative_fft_2d"})," and ",(0,r.jsx)(t.code,{children:"iterative_fft_2d_copy"})," may ",(0,r.jsx)(t.strong,{children:"resize the buffer and change the effective width/height"})]}),"\n"]}),(0,r.jsxs)(t.p,{children:["If you require strict ",(0,r.jsx)(t.em,{children:"same-size in / same-size out"})," behavior, ensure your input dimensions are already powers of two before calling these functions."]})]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Function"}),(0,r.jsx)(t.th,{style:{textAlign:"right"},children:"Signature"}),(0,r.jsx)(t.th,{children:"Purpose"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"is_power_of_two"})}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:(0,r.jsx)(t.code,{children:"bool is_power_of_two(size_t n)"})}),(0,r.jsxs)(t.td,{children:["Check if ",(0,r.jsx)(t.code,{children:"n"})," is a power of two."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"next_power_of_two"})}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:(0,r.jsx)(t.code,{children:"size_t next_power_of_two(size_t n)"})}),(0,r.jsxs)(t.td,{children:["Return the next power of two ",(0,r.jsxs)(t.span,{className:"katex",children:[(0,r.jsx)(t.span,{className:"katex-mathml",children:(0,r.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,r.jsxs)(t.semantics,{children:[(0,r.jsxs)(t.mrow,{children:[(0,r.jsx)(t.mo,{children:"\u2265"}),(0,r.jsx)(t.mi,{children:"n"})]}),(0,r.jsx)(t.annotation,{encoding:"application/x-tex",children:"\\ge n"})]})})}),(0,r.jsxs)(t.span,{className:"katex-html","aria-hidden":"true",children:[(0,r.jsxs)(t.span,{className:"base",children:[(0,r.jsx)(t.span,{className:"strut",style:{height:"0.7719em",verticalAlign:"-0.136em"}}),(0,r.jsx)(t.span,{className:"mrel",children:"\u2265"}),(0,r.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,r.jsxs)(t.span,{className:"base",children:[(0,r.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,r.jsx)(t.span,{className:"mord mathnormal",children:"n"})]})]})]}),"."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"bit_reverse_permute"})}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:(0,r.jsx)(t.code,{children:"void bit_reverse_permute(std::vector<cd> &a)"})}),(0,r.jsx)(t.td,{children:"In-place bit-reversal permutation (required for DIT iterative FFT)."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"pad_to_pow_two"})}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:(0,r.jsx)(t.code,{children:"void pad_to_pow_two(std::vector<cd> &a, size_t &N)"})}),(0,r.jsxs)(t.td,{children:["Resize and zero-pad ",(0,r.jsx)(t.code,{children:"a"})," to next power-of-two; updates ",(0,r.jsx)(t.code,{children:"N"})," (the size of the array)."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"iterative_fft"})}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:(0,r.jsx)(t.code,{children:"void iterative_fft(std::vector<cd> &a, bool inverse = false)"})}),(0,r.jsxs)(t.td,{children:["In-place iterative FFT. ",(0,r.jsx)(t.code,{children:"inverse=true"})," computes inverse and normalizes by ",(0,r.jsx)(t.code,{children:"1/N"}),"."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"fft_copy"})}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:(0,r.jsx)(t.code,{children:"std::vector<cd> fft_copy(const std::vector<cd> &input, bool inverse = false)"})}),(0,r.jsxs)(t.td,{children:["Convenience wrapper around ",(0,r.jsx)(t.code,{children:"iterative_fft"})," returning a new vector with the FFT result."]})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"iterative_fft_2d"})}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:(0,r.jsx)(t.code,{children:"void iterative_fft_2d(std::vector<cd> &a, size_t width, size_t height, bool inverse = false)"})}),(0,r.jsx)(t.td,{children:"In-place 2D FFT (pads to power-of-two dims if needed)."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"iterative_fft_2d_copy"})}),(0,r.jsx)(t.td,{style:{textAlign:"right"},children:(0,r.jsx)(t.code,{children:"std::vector<cd> iterative_fft_2d_copy(const std::vector<cd> &input, size_t width, size_t height, bool inverse = false)"})}),(0,r.jsx)(t.td,{children:"Returns a new vector with the 2D FFT result."})]})]})]}),"\n",(0,r.jsx)(t.admonition,{title:"Notes",type:"info",children:(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Sign convention: forward uses ",(0,r.jsx)(t.code,{children:"-2\u03c0i"}),", inverse uses ",(0,r.jsx)(t.code,{children:"+2\u03c0i"})," and divides by ",(0,r.jsx)(t.code,{children:"N"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["Implementation uses ",(0,r.jsx)(t.code,{children:"std::polar"})," to create stage primitive roots."]}),"\n"]})})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);