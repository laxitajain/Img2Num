name: Issue Take/Untake Workflow

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]
  schedule:
    - cron: "0 0 * * 0" # weekly cleanup (UTC)

permissions:
  contents: read
  issues: write

jobs:
  take_untake:
    if: >
      github.event_name == 'issues' ||
      (github.event_name == 'issue_comment' &&
      github.actor != 'github-actions[bot]')

    runs-on: ubuntu-latest
    steps:
      - name: Handle issue take/untake
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = context.payload.issue.number;
            const takenLabel = 'taken';
            const EXPIRE_MS = 21 * 24 * 60 * 60 * 1000;

            const META_START = '<!-- issue-take-untake:meta';
            const META_END = '-->';
            const BODY_START = '<!-- issue-take-untake:start -->';
            const BODY_END = '<!-- issue-take-untake:end -->';

            const isIssueOpen = context.eventName === 'issues';
            const isComment = context.eventName === 'issue_comment';

            const issue = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
            let body = issue.data.body || '';

            function extractMeta(body) {
              const start = body.indexOf(META_START);
              if (start === -1) return { owner: null, ts: 0 };

              const end = body.indexOf(META_END, start);
              try {
                return JSON.parse(body.slice(start + META_START.length, end).trim());
              } catch {
                return { owner: null, ts: 0 };
              }
            }

            function writeMeta(body, meta) {
              const block = `\n${META_START}\n${JSON.stringify(meta)}\n${META_END}\n`;
              return body.includes(META_START)
                ? body.replace(new RegExp(`${META_START}[\\s\\S]*?${META_END}`), block.trim())
                : block + body;
            }

            function buildUntakenBanner() {
              return `
            ${BODY_START}
            > [!TIP]
            > This issue hasn't been claimed yet. Comment \`/take\` to work on it.
            ${BODY_END}
            `.trim();
            }

            function buildTakenBanner(user) {
              return `
            ${BODY_START}
            > [!CAUTION]
            > This issue has been claimed by **@${user}**.
            >
            > So, it is advisable to not work on it while it is claimed.
            >
            > **For @${user}:** Comment \`/untake\` to unclaim.
            ${BODY_END}
            `.trim();
            }

            function updateBanner(body, banner) {
              return body.includes(BODY_START)
                ? body.replace(new RegExp(`${BODY_START}[\\s\\S]*?${BODY_END}`), banner)
                : `${banner}\n\n---\n\n${body}`;
            }

            async function getPermission(username) {
              const res = await github.rest.repos.getCollaboratorPermissionLevel({
                owner,
                repo,
                username
              });
              return res.data.permission;
            }

            let meta = extractMeta(body);

            // Normalize expired claim
            if (meta.owner && meta.ts && Date.now() - meta.ts > EXPIRE_MS) {
              meta = { owner: null, ts: 0 };
            }

            // Issue opened â†’ initialize
            if (isIssueOpen) {
              body = writeMeta(body, meta);
              body = updateBanner(body, buildUntakenBanner());
              await github.rest.issues.update({ owner, repo, issue_number: issueNumber, body });
              return;
            }

            if (!isComment) return;

            const comment = context.payload.comment;
            const commenter = comment.user.login;
            const text = (comment.body || '').trim();

            const takeMatch = text.match(/^\/take(?:\s+@(\w+))?/i);
            const untakeMatch = text.match(/^\/untake(?:\s+@(\w+))?/i);

            if (!takeMatch && !untakeMatch) return;

            const targetUser = (takeMatch || untakeMatch)?.[1] || commenter;
            const perm = await getPermission(commenter);
            const isPrivileged = ['triage', 'write', 'maintain', 'admin'].includes(perm);

            // TAKE
            if (takeMatch) {
              if (meta.owner) return;
              if (targetUser !== commenter && !isPrivileged) return;

              meta = { owner: targetUser, ts: Date.now() };
              body = writeMeta(body, meta);
              body = updateBanner(body, buildTakenBanner(targetUser));

              await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: [takenLabel] });
              await github.rest.issues.update({ owner, repo, issue_number: issueNumber, body });
              return;
            }

            // UNTAKE
            if (untakeMatch) {
              if (meta.owner !== targetUser && !isPrivileged) return;

              meta = { owner: null, ts: 0 };
              body = writeMeta(body, meta);
              body = updateBanner(body, buildUntakenBanner());

              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: takenLabel });
              } catch {}

              await github.rest.issues.update({ owner, repo, issue_number: issueNumber, body });
            }

  cleanup:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: Expire stale claims
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const EXPIRE_MS = 21 * 24 * 60 * 60 * 1000;
            const META_START = '<!-- issue-take-untake:meta';
            const META_END = '-->';

            const issues = await github.rest.issues.listForRepo({
              owner,
              repo,
              labels: 'taken',
              state: 'open',
              per_page: 100
            });

            for (const issue of issues.data) {
              const body = issue.body || '';
              const start = body.indexOf(META_START);
              if (start === -1) continue;

              const end = body.indexOf(META_END, start);
              let meta;
              try {
                meta = JSON.parse(body.slice(start + META_START.length, end).trim());
              } catch {
                continue;
              }

              if (meta.ts && Date.now() - meta.ts > EXPIRE_MS) {
                const cleaned = body.replace(new RegExp(`${META_START}[\\s\\S]*?${META_END}`), '');
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: issue.number,
                  body: cleaned
                });
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: issue.number, name: 'taken' });
                } catch {}
              }
            }
